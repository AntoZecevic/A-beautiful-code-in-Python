import time

def i2spalte_zeile(i):
  zeile = i // 9
  spalte = i % 9
  return spalte,zeile

def print_board():
  for feld in freie_stellen:
    b[feld] = 0
  for i in range(81):
    print () if i % 9 == 0 else None
    pos = i2spalte_zeile(i)
    print(b[pos],' ',end='')
  print()
  


def change_board(spalte,zeile,zahl,löschen):
  if löschen:
    spalten[spalte].add(zahl)
    zeilen[zeile].add(zahl)
    quadrate[zeile//3*3+spalte//3].add(zahl)
    freie_stellen.add((spalte,zeile))
  else:
    spalten[spalte].remove(zahl)
    zeilen[zeile].remove(zahl)
    quadrate[zeile//3*3+spalte//3].remove(zahl)
    b[(spalte, zeile)] = zahl
    freie_stellen.remove((spalte,zeile))

def bestes_Feld():
  best = 9
  best_feld = ()
  for feld in freie_stellen:
    spalte, zeile = feld
    
    #die in der jeweiligen Spalte, Zeile, Quadrat möglichen Lösungen werden
    #UND-Verknüpft (=Intersection). In m liegt dann das Set() der möglichen Lösungen
    #die in allen drei Sets für dieses Feld in spalte, zeile übereinstimmen
    m = quadrate[zeile//3*3+spalte//3] & spalten[spalte] & zeilen[zeile]
    
    #wenn bei einem der freien Felder kein gültiger Eintrag mehr möglich ist (m = leer)
    #dann befinden wir uns in einer Sackgasse und geben sofort dieses leere Feld zurück
    if not m:
      return (spalte, zeile ,m)
    länge = len(m)
    
    #wenn die Anzahl der gültigen Einträge = 1 ist, können wir das direkt zurückgeben 
    if länge == 1:
      return (spalte, zeile, m)
    if länge < best:
      best = länge
      best_feld = (spalte, zeile, m)
  return best_feld

def solve():
  #wenn es keine freien Stellen mehr gibt, haben wir die Lösung gefunden
  #und geben True zurück (führt in jeder Rekursionsstufe zu einen Return = True)
  if not freie_stellen:
    return True
  
  #wir holen uns das Feld mit der geringsten Anzahl an Möglichkeiten
  spalte, zeile, moeg = bestes_Feld()
  
  #hier befinden wir uns in einer Sackgasse und gehen eine Rekursionsstufe
  #zurück, machen dort aber mit dem Löschen des vorher gesetzten Feldes weiter
  if not moeg:
    return False
  
  #hier probieren wir alle möglichen Einträge für das Feld mit der geringsten Zahl
  #an Möglichkeiten aus
  for m in moeg:
    #die Möglichkeit wird gesetzt
    change_board(spalte, zeile, m, False)
    #danach springen wir eine Rekursionsstiefe tiefer und machen dort weiter
    
    #wenn solve true zurückliefert (= Lösung gefunden), dann liefert diese Rekursionsstufe
    #auch True zurücke. Dadurch kaskadieren die Trues durch alle Rekursionsstufen zurück
    #bis auch der erste Aufruf der Funktion beendet ist
    if solve():
      return True
    
    #wenn aber solve ein False zurückliefert, landen wir hier
    #hier wird der zuvor ausprobierte Eintrag wieder zurückgenommen
    #und durch die Schleife der nächste Eintrag ausprobiert
    change_board(spalte, zeile, m, True)
    
#alle Möglichkeiten durchprobiert wurden, kehren wir um eine Rekursionsstiefe zurück
#und setzen dort den letzten wert zurück usw. usw.    
  
full_set = {1,2,3,4,5,6,7,8,9}
sudokus = []

with open ('Sudoku_top100_hard.txt') as f:
  for c, sudoku in enumerate(f):
    start = time.perf_counter()
    board = [int(char) for char in sudoku.strip()]
    b = {}
    #enthalten die möglichen Einträge, die noch in der jeweiligen
    #Spalte, Zeile oder Quadrat möglich sind
    spalten = []
    zeilen = []
    quadrate = []
    freie_stellen = set()

    for _ in range(9):
      spalten.append(full_set.copy())
      zeilen.append(full_set.copy())
      quadrate.append(full_set.copy())
            

    for i in range(81):
      spalte, zeile = i2spalte_zeile(i)
      b[(spalte,zeile)] = board[i]
      freie_stellen.add((spalte,zeile))
      if b[(spalte,zeile)] == 0:
        continue
      change_board(spalte,zeile,board[i],False)

    solve()
    # print_board()
    # if not freie_stellen:
    #   print(f'Nr. {c} gelöst in {time.perf_counter()-start:4.4f} Sek.')
    # else:
    #   print(f'Nr. {c} unlösbar festgestellt nach {time.perf_counter()-start:4.4f} Sek.')
    zeit = time.perf_counter()-start
    sudokus.append((zeit,c+1))
    #print(f'Nr. {c + 1:5d} in {zeit:7.4f} Sek.')
    
summe_zeit = sum([x for x,y in sudokus])
sudokus.sort(reverse=True)    
print(f'{c+1} Sudokus gelöst in {summe_zeit:7.4f} Sek. ({summe_zeit/(c+1):7.4f})')
for i in range(10):
  print(f'{sudokus[i][0]:7.4f} Sek. für Nr. {sudokus[i][1]:5d}')
